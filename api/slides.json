[
  {
    "id": 1,
    "title": "Introduction to NgRx",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "What is state management and why it's useful?"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "State management is managing data and state changes in an application"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Useful for:"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Handling shared state between components"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Maintaining immutability and unidirectional data flow"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Caching data and optimizing performance"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Increased predictability and debugging capabilities"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which of the following is a key benefit of using NgRx for state management?",
        "options": [
          "It encourages mutable data structures",
          "It isolates state management per component",
          "It provides a single source of truth for application state",
          "It lacks integration with RxJS"
        ],
        "answer": 2
      }
    ]
  },
  {
    "id": 2,
    "title": "Introduction to NgRx (cont.)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Brief history of Redux and NgRx"
      },
      {
        "type": "image",
        "src": "https://ngrx.io/assets/images/badge.svg",
        "alt": "NgRx logo",
        "class": "w10 sp1"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Redux pioneered the concept of centralized state management"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "NgRx applies Redux principles built for Angular"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Provides patterns and utilities for managing state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Integrates with RxJS for reactive state management"
          }
        ]
      }
    ]
  },
  {
    "id": 3,
    "title": "Introduction to NgRx (cont.)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Key benefits of NgRx"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Type Safety"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Single source of truth for state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "More predictable state changes"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Increased performance through immutable data"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Powerful dev tools for debugging (Redux Ext)"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "RxJS integration for reactive state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Encourages best practices including TESTING"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Scalable architecture"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which of these is NOT a key benefit of using NgRx?",
        "options": [
          "Increased performance through immutable data",
          "Lack of debugging tools",
          "Single source of truth for state",
          "Encourages best practices"
        ],
        "answer": 1
      }
    ]
  },
  {
    "id": 4,
    "title": "Core Concepts Overview",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Immutability"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Store"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Actions"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Reducers"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Selectors"
      }
    ]
  },
  {
    "id": 5,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Immutability"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Definition:"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Unchanging over time, state is not mutated"
          }
        ]
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Benefits:"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Predictability - no unexpected changes"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Performance - cheap referential equality"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Time travel debugging"
          }
        ]
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Strategies in JavaScript:"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Spread syntax"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Object.assign"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Other libs like Immer adn Immutable.js"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept represents unchanging state?",
        "options": ["Reducers", "Actions", "Immutability", "Selectors"],
        "answer": 2
      }
    ]
  },
  {
    "id": 6,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Store"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Single source of truth for state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Manages state as observable data with RxJS"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Dispatches actions"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Registers reducers to handle state transitions"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept dispatches actions?",
        "options": ["Immutability", "Reducers", "Store", "Selectors"],
        "answer": 2
      }
    ]
  },
  {
    "id": 7,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Actions"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Events describing state changes"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Carry payload data"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Have a unique type for traceability"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Registers reducers to handle state transitions"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept describes state change events?",
        "options": ["Store", "Actions", "Immutability", "Reducers"],
        "answer": 1
      }
    ]
  },
  {
    "id": 8,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Reducers"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Pure functions defining state transitions"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Use spread syntax for immutable update"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Handle actions by type"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Provide initial state"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept handles modifying state based on action types?",
        "options": ["Selectors", "Actions", "Store", "Reducers"],
        "answer": 3
      }
    ]
  },
  {
    "id": 9,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Selectors"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Derive/transform data from state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Enable efficient recomputation"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Parameterization and composition"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept uses memoization and parameters for efficiency?",
        "options": ["Store", "Actions", "Selectors", "Reducers"],
        "answer": 2
      }
    ]
  },
  {
    "id": 10,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Lifecycle"
      },
      {
        "type": "image",
        "src": "https://ngrx.io/generated/images/guide/store/state-management-lifecycle.png",
        "alt": "",
        "class": "w75"
      },
      {
        "type": "question",
        "question": "What is the correct sequence of the NgRx state management lifecycle?",
        "options": [
          "Selector -> Reducer -> Store -> Action",
          "Store -> Reducer -> Action -> Selector",
          "Action -> Store -> Selector -> Reducer",
          "Action -> Reducer -> Store -> Selector"
        ],
        "answer": 3
      }
    ]
  },
  {
    "id": 11,
    "title": "Hands-On Core Concepts #1",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Hands-On Core Concepts #1 - Conversion to NgRx Store"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add Ngrx & Redux DevTools"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Install NgRx"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "npm install @ngrx/store --save"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "import the StoreModule in our AppModule (src/app/app.module.ts (imports))"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "import { StoreModule } from '@ngrx/store';"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add the import (src/app/app.module.ts (StoreModule))"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "@NgModule({\n  declarations: [AppComponent, DeckComponent, NotFoundComponent],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    StoreModule.forRoot({}),\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add Redux DevTools Chrome Extension"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "https://tinyurl.com/reduxDevToolsExt"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "install NgRx Store DevTools"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "npm install @ngrx/store-devtools --save"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "import and add NgRx Store DevTools to AppModule"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "import { StoreDevtoolsModule } from '@ngrx/store-devtools';\n\n  @NgModule({\n  declarations: [AppComponent, DeckComponent, NotFoundComponent],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    StoreModule.forRoot({}),\n    StoreDevtoolsModule.instrument({\n      maxAge: 25, // Retains last 25 states\n      // logOnly: !isDevMode(), // Restrict extension to log-only mode\n      autoPause: true, // Pauses recording actions and state changes when the extension window is not open\n      trace: false, //  If set to true, will include stack trace for every dispatched action, so you can see it in trace tab jumping directly to that part of code\n      traceLimit: 75, // maximum stack trace frames to be stored (in case trace option was provided as true)\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n"
      }
    ]
  },
  {
    "id": 12,
    "title": "Hands-On Core Concepts #1 (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Now for the fun stuff... Reducers!"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add the DeckReducer with initial state"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "// under fe/src/state/ add deck.reducer.ts\n\nimport { DeckState } from 'src/types/presentation-deck';\n\nimport { createReducer, on } from '@ngrx/store';\n\nexport const initialDeckState: Readonly<DeckState> = {\n  currentSlide: null,\n  slides: [],\n};\n\nexport const DeckReducer = createReducer(initialDeckState);\n"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "and now import and add the reducer to our root state in the AppModule"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "StoreModule.forRoot({ presentation: DeckReducer })"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "check out our initial app state with Redux DevTools..."
      }
    ]
  },
  {
    "id": 13,
    "title": "Hands-On Core Concepts #1 (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Lunchtime!"
      },
      {
        "type": "image",
        "src": "/assets/lunch.gif",
        "alt": "lunch",
        "class": "sp2"
      }
    ]
  },
  {
    "id": 14,
    "title": "Hands-On Core Concepts #2 - Actions",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Hands-On Core Concepts #2 - Actions"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Actions express unique events that happen throughout your application. From user interaction with the page, external interaction through network requests, and direct interaction with device APIs, these and more events are described with actions."
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Define slide deck actions (action party)"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Dispatch for navigation and triggering reducers etc."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Handle in reducers"
          }
        ]
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Writing actions"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "There are a few rules to writing good actions within your application."
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Upfront - write actions before developing features to understand and gain a shared knowledge of the feature being implemented."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Divide - categorize actions based on the event source."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Many - actions are inexpensive to write, so the more actions you write, the better you express flows in your application."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Event-Driven - capture events not commands as you are separating the description of an event and the handling of that event."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Descriptive - provide context that are targeted to a unique event with more detailed information you can use to aid in debugging with the developer tools."
          }
        ]
      }
    ]
  },
  {
    "id": 15,
    "title": "Hands-On Core Concepts #2 - Actions (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Action Party!"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Write Action Types with a pattern and stick with it!"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "In Primum, I used '[Actor] Action Type' and followed a Success and Failure pattern when using an effect, and organized them all under a CaseActions object."
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "[user] clicked order button"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "[primum] get status, [primum] get status success, [primum] get status failure"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "[user] clicked close modal"
          }
        ]
      },
      {
        "type": "image",
        "src": "/assets/primum-actions.png",
        "alt": "actions",
        "class": "sp3"
      }
    ]
  },
  {
    "id": 16,
    "title": "Hands-On Core Concepts #2 - Actions (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Actions!"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add the DeckActions"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "// under fe/src/state/ add deck.actions.ts\n\nimport { Slide } from 'src/types/presentation-deck';\n\nimport { createAction, props } from '@ngrx/store';\n\nexport const deckActions = {\n  slides: {\n    load: createAction('[deck] load slides'),\n    loadSuccess: createAction(\n      '[deck] load slides success',\n      props<{ payload: Slide[] }>()\n    ),\n    loadFailure: createAction(\n      '[deck] load slides failure',\n      props<{ payload: Error }>()\n    ),\n    increment: createAction('[user] increment slide'),\n    decrement: createAction('[user] decrement slide'),\n  },\n};"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "in the deck.component.ts import our DeckActions, inject Store, and add:"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "// don't forget to import/inject Store\n\nadd  ngOnInit() {\n    this.store.dispatch(deckActions.slides.load())\n  }"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "next we'll add reducers, but for now lets see one of our actions fire off and take note of how it is indicated in Redux DevTools..."
      }
    ]
  },
  {
    "id": 17,
    "title": "Hands-On Core Concepts #3 - Reducers",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Hands-On Core Concepts #3 - Reducers"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Reducers are responsible for maintaining the immutability of the state by returning a new state object instead of modifying the existing state directly. This approach helps in tracking changes effectively and maintaining a clear history of state changes."
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "I like to think of Reducers as funnels current state and action enter through the top and new state comes out the bottom."
      },
      {
        "type": "image",
        "src": "/assets/reducers.png",
        "alt": "Reducers",
        "class": "w25"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "State and Action Entry (Top of Funnel): At the funnel's start, you input the app's current state and action. The state shows data and app status, while the action describes an event. Actions are simple JavaScript objects with a type property denoting the action's goal and often carry extra data."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Reducer Processing (Inside the Funnel): The reducer, the funnel's core, processes the state and action. Like machinery, it transforms them into a new state. Reducers are clean functions, taking current state and action, and deciding how to apply the action. Based on the action's type and payload, it computes state changes."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "New State Generation (Bottom of Funnel): While traversing the reducer, the state and action trigger computations, transformations, or updates. These create a fresh state representing action-induced changes. This updated state captures the new data and app state, completing the process."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "The funnel's bottom delivers the new state. It reflects the app's modified data and state after action processing."
          }
        ]
      }
    ]
  },
  {
    "id": 18,
    "title": "Hands-On Core Concepts #3 - Reducers (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Reducers"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "let's go back to our deck.reducer.ts file and handle our first state change with reducers for our slides.increment and slides.decrement actions"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "import { DeckState } from 'src/types/presentation-deck';\n\nimport { createReducer, on } from '@ngrx/store';\n\nimport { deckActions } from './deck.actions';\n\nexport const initialDeckState: Readonly<DeckState> = {\n  currentSlide: null,\n  slides: [],\n};\n\nexport const DeckReducer = createReducer(\n  initialDeckState,\n  on(deckActions.slides.increment, (state) => {\n    const newState: DeckState = { ...state }; // necessary as it is Readonly\n    // increment logic here\n    return newState;\n  }),\n  on(deckActions.slides.decrement, (state) => {\n    const newState: DeckState = { ...state };\n    // decrement logic here\n    return newState;\n  })\n);\n"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "let's add another reducer for our slides.loadSuccess action and note the payload"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "export const DeckReducer = createReducer(\n  initialDeckState,\n  on(deckActions.slides.loadSuccess, (state, { payload }) => {\n    const newState: DeckState = {\n      ...state,\n      slides: payload,\n      currentSlide: payload[0],\n      foo: 'bar'\n    };\n    return newState;\n  }),\n  on(deckActions.slides.increment, (state) => {\n    const newState = { ...state }; // necessary as it is Readonly\n    // increment logic here\n    return newState;\n  }),\n  on(deckActions.slides.decrement, (state) => {\n    const newState = { ...state };\n    // decrement logic here\n    return newState;\n  })\n);"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Oops looks like we added an illegal property! Lets fix it and thankfully TypeScript is on guard ðŸ’ª"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "Notice we are receiving payload from our action then and spreading the previous state; first into our new state and overwriting slides, and then currentSlide with our new action payload: Slides[][0]"
      }
    ]
  }
]
