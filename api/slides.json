[
  {
    "id": 1,
    "title": "Introduction to NgRx",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "What is state management and why it's useful?"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "State management is managing data and state changes in an application"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Useful for:"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Handling shared state between components"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Maintaining immutability and unidirectional data flow"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Caching data and optimizing performance"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Increased predictability and debugging capabilities"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which of the following is a key benefit of using NgRx for state management?",
        "options": [
          "It encourages mutable data structures",
          "It isolates state management per component",
          "It provides a single source of truth for application state",
          "It lacks integration with RxJS"
        ],
        "answer": 2
      }
    ]
  },
  {
    "id": 2,
    "title": "Introduction to NgRx (cont.)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Brief history of Redux and NgRx"
      },
      {
        "type": "image",
        "src": "https://ngrx.io/assets/images/badge.svg",
        "alt": "NgRx logo",
        "class": "w10 sp1"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Redux pioneered the concept of centralized state management"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "NgRx applies Redux principles built for Angular"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Provides patterns and utilities for managing state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Integrates with RxJS for reactive state management"
          }
        ]
      }
    ]
  },
  {
    "id": 3,
    "title": "Introduction to NgRx (cont.)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Key benefits of NgRx"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Type Safety"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Single source of truth for state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "More predictable state changes"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Increased performance through immutable data"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Powerful dev tools for debugging (Redux Ext)"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "RxJS integration for reactive state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Encourages best practices including TESTING"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Scalable architecture"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which of these is NOT a key benefit of using NgRx?",
        "options": [
          "Increased performance through immutable data",
          "Lack of debugging tools",
          "Single source of truth for state",
          "Encourages best practices"
        ],
        "answer": 1
      }
    ]
  },
  {
    "id": 4,
    "title": "Core Concepts Overview",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Immutability"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Store"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Actions"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Reducers"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Selectors"
      }
    ]
  },
  {
    "id": 5,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Immutability"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Definition:"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Unchanging over time, state is not mutated"
          }
        ]
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Benefits:"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Predictability - no unexpected changes"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Performance - cheap referential equality"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Time travel debugging"
          }
        ]
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Strategies in JavaScript:"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Spread syntax"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Object.assign"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Other libs like Immer adn Immutable.js"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept represents unchanging state?",
        "options": ["Reducers", "Actions", "Immutability", "Selectors"],
        "answer": 2
      }
    ]
  },
  {
    "id": 6,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Store"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Single source of truth for state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Manages state as observable data with RxJS"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Dispatches actions"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Registers reducers to handle state transitions"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Exposes the state as an observable and updates components when a new state is reduced"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept dispatches actions?",
        "options": ["Immutability", "Reducers", "Store", "Selectors"],
        "answer": 2
      }
    ]
  },
  {
    "id": 7,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Actions"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Events describing state changes"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Carry payload data"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Have a unique type for traceability"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Registers reducers to handle state transitions"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept describes state change events?",
        "options": ["Store", "Actions", "Immutability", "Reducers"],
        "answer": 1
      }
    ]
  },
  {
    "id": 8,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Reducers"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Pure functions defining state transitions - pure functions that take current state + action and return new state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Use spread syntax for immutable update"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Handle actions by type"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Provide initial state"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept handles modifying state based on action types?",
        "options": ["Selectors", "Actions", "Store", "Reducers"],
        "answer": 3
      }
    ]
  },
  {
    "id": 9,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Selectors"
      },
      {
        "type": "list",
        "listType": "unordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Derive/transform data from state"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Enable efficient recomputation"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Parameterization and composition"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Provide memoization to avoid repeat computations"
          }
        ]
      },
      {
        "type": "question",
        "question": "Which NgRx concept uses memoization and parameters for efficiency?",
        "options": ["Store", "Actions", "Selectors", "Reducers"],
        "answer": 2
      }
    ]
  },
  {
    "id": 10,
    "title": "Core Concepts Overview (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Lifecycle"
      },
      {
        "type": "image",
        "src": "https://ngrx.io/generated/images/guide/store/state-management-lifecycle.png",
        "alt": "",
        "class": "w75"
      },
      {
        "type": "question",
        "question": "What is the correct sequence of the NgRx state management lifecycle?",
        "options": [
          "Selector -> Reducer -> Store -> Action",
          "Store -> Reducer -> Action -> Selector",
          "Action -> Store -> Selector -> Reducer",
          "Action -> Reducer -> Store -> Selector"
        ],
        "answer": 3
      }
    ]
  },
  {
    "id": 11,
    "title": "Hands-On Core Concepts #1",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Hands-On Core Concepts #1 - Conversion to NgRx Store"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Clone the repo:"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "git clone https://github.com/jzevin/ngrx-training-8-2023.git"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "change the dir & install dependencies for the API and frontend:"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "cd ngrx-training-8-2023/api && npm i && cd ../fe && npm i"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add Ngrx & Redux DevTools"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Install NgRx"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "npm install @ngrx/store --save"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "import the StoreModule in our AppModule (src/app/app.module.ts (imports))"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "import { StoreModule } from '@ngrx/store';"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add the import (src/app/app.module.ts (StoreModule))"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "@NgModule({\n  declarations: [AppComponent, DeckComponent, NotFoundComponent],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    StoreModule.forRoot({}),\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add Redux DevTools Chrome Extension"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "https://tinyurl.com/reduxDevToolsExt"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "install NgRx Store DevTools"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "npm install @ngrx/store-devtools --save"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "import and add NgRx Store DevTools to AppModule"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "import { StoreDevtoolsModule } from '@ngrx/store-devtools';\n\n  @NgModule({\n  declarations: [AppComponent, DeckComponent, NotFoundComponent],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    HttpClientModule,\n    StoreModule.forRoot({}),\n    StoreDevtoolsModule.instrument({\n      maxAge: 25, // Retains last 25 states\n      // logOnly: !isDevMode(), // Restrict extension to log-only mode\n      autoPause: true, // Pauses recording actions and state changes when the extension window is not open\n      trace: false, //  If set to true, will include stack trace for every dispatched action, so you can see it in trace tab jumping directly to that part of code\n      traceLimit: 75, // maximum stack trace frames to be stored (in case trace option was provided as true)\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "finally start the API and frontend"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "cd ngrx-training-8-2023/api && npm run start\n\n# in a new terminal\n\ncd ngrx-training-8-2023/fe && ng serve"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "our Angular frontend should be running at:"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "http://localhost:4200"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "and our Express API Slides endpoint at:"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "http://localhost:3000/slides"
      }
    ]
  },
  {
    "id": 12,
    "title": "Hands-On Core Concepts #1 (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Now for the fun stuff... Reducers!"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add the DeckReducer with initial state"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "// under fe/src/state/ add deck.reducer.ts\n\nimport { DeckState } from 'src/types/presentation-deck';\n\nimport { createReducer, on } from '@ngrx/store';\n\nexport const initialDeckState: Readonly<DeckState> = {\n  currentSlide: null,\n  slides: [],\n};\n\nexport const DeckReducer = createReducer(initialDeckState);\n"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "and now import and add the reducer to our root state in the AppModule"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "StoreModule.forRoot({ presentation: DeckReducer })"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "check out our initial app state with Redux DevTools..."
      }
    ]
  },
  {
    "id": 13,
    "title": "Hands-On Core Concepts #1 (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Lunchtime!"
      },
      {
        "type": "image",
        "src": "/assets/lunch.gif",
        "alt": "lunch",
        "class": "sp2"
      }
    ]
  },
  {
    "id": 14,
    "title": "Hands-On Core Concepts #2 - Actions",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Hands-On Core Concepts #2 - Actions"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Actions express unique events that happen throughout your application. From user interaction with the page, external interaction through network requests, and direct interaction with device APIs, these and more events are described with actions."
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Define slide deck actions (action party)"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Dispatch for navigation and triggering reducers etc."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Handle in reducers"
          }
        ]
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Writing actions"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "There are a few rules to writing good actions within your application."
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Upfront - write actions before developing features to understand and gain a shared knowledge of the feature being implemented."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Divide - categorize actions based on the event source."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Many - actions are inexpensive to write, so the more actions you write, the better you express flows in your application."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Event-Driven - capture events not commands as you are separating the description of an event and the handling of that event."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Descriptive - provide context that are targeted to a unique event with more detailed information you can use to aid in debugging with the developer tools."
          }
        ]
      }
    ]
  },
  {
    "id": 15,
    "title": "Hands-On Core Concepts #2 - Actions (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Action Party!"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Write Action Types with a pattern and stick with it!"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "In Primum, I used '[Actor] Action Type' and followed a Success and Failure pattern when using an effect, and organized them all under a CaseActions object."
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "[user] clicked order button"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "[primum] get status, [primum] get status success, [primum] get status failure"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "[user] clicked close modal"
          }
        ]
      },
      {
        "type": "image",
        "src": "/assets/primum-actions.png",
        "alt": "actions",
        "class": "sp3"
      }
    ]
  },
  {
    "id": 16,
    "title": "Hands-On Core Concepts #2 - Actions (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Actions!"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "add the DeckActions"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "// under fe/src/state/ add deck.actions.ts\n\nimport { Slide } from 'src/types/presentation-deck';\n\nimport { createAction, props } from '@ngrx/store';\n\nexport const deckActions = {\n  slides: {\n    load: createAction('[deck] load slides'),\n    loadSuccess: createAction(\n      '[deck] load slides success',\n      props<{ payload: Slide[] }>()\n    ),\n    loadFailure: createAction(\n      '[deck] load slides failure',\n      props<{ payload: Error }>()\n    ),\n    increment: createAction('[user] increment slide'),\n    decrement: createAction('[user] decrement slide'),\n  },\n};"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "in the deck.component.ts import our DeckActions, inject Store, and add:"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "// don't forget to import/inject Store\n\nadd  ngOnInit() {\n    this.store.dispatch(deckActions.slides.load())\n  }"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "next we'll add reducers, but for now lets see one of our actions fire off and take note of how it is indicated in Redux DevTools..."
      }
    ]
  },
  {
    "id": 17,
    "title": "Hands-On Core Concepts #3 - Reducers",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Hands-On Core Concepts #3 - Reducers"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Reducers are responsible for maintaining the immutability of the state by returning a new state object instead of modifying the existing state directly. This approach helps in tracking changes effectively and maintaining a clear history of state changes."
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "I like to think of Reducers as funnels current state and action enter through the top and new state comes out the bottom."
      },
      {
        "type": "image",
        "src": "/assets/reducers.png",
        "alt": "Reducers",
        "class": "w25"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "State and Action Entry (Top of Funnel): At the funnel's start, you input the app's current state and action. The state shows data and app status, while the action describes an event. Actions are simple JavaScript objects with a type property denoting the action's goal and often carry extra data."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Reducer Processing (Inside the Funnel): The reducer, the funnel's core, processes the state and action. Like machinery, it transforms them into a new state. Reducers are clean functions, taking current state and action, and deciding how to apply the action. Based on the action's type and payload, it computes state changes."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "New State Generation (Bottom of Funnel): While traversing the reducer, the state and action trigger computations, transformations, or updates. These create a fresh state representing action-induced changes. This updated state captures the new data and app state, completing the process."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "The funnel's bottom delivers the new state. It reflects the app's modified data and state after action processing."
          }
        ]
      }
    ]
  },
  {
    "id": 18,
    "title": "Hands-On Core Concepts #3 - Reducers (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Reducers"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "let's go back to our deck.reducer.ts file and handle our first state change with reducers for our slides.increment and slides.decrement actions"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "import { DeckState } from 'src/types/presentation-deck';\n\nimport { createReducer, on } from '@ngrx/store';\n\nimport { deckActions } from './deck.actions';\n\nexport const initialDeckState: Readonly<DeckState> = {\n  currentSlide: null,\n  slides: [],\n};\n\nexport const DeckReducer = createReducer(\n  initialDeckState,\n  on(deckActions.slides.increment, (state) => {\n    const newState: DeckState = { ...state }; // necessary as it is Readonly\n    // increment logic here\n    return newState;\n  }),\n  on(deckActions.slides.decrement, (state) => {\n    const newState: DeckState = { ...state };\n    // decrement logic here\n    return newState;\n  })\n);\n"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "let's add another reducer for our slides.loadSuccess action and note the payload"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "export const DeckReducer = createReducer(\n  initialDeckState,\n  on(deckActions.slides.loadSuccess, (state, { payload }) => {\n    const newState: DeckState = {\n      ...state,\n      slides: payload,\n      currentSlide: payload[0],\n      foo: 'bar'\n    };\n    return newState;\n  }),\n  on(deckActions.slides.increment, (state) => {\n    const newState = { ...state }; // necessary as it is Readonly\n    // increment logic here\n    return newState;\n  }),\n  on(deckActions.slides.decrement, (state) => {\n    const newState = { ...state };\n    // decrement logic here\n    return newState;\n  })\n);"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Oops looks like we added an illegal property! Lets fix it and thankfully TypeScript is on guard ðŸ’ª"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "Notice we are receiving payload from our action then and spreading the previous state; first into our new state and overwriting slides, and then currentSlide with our new action payload: Slides[][0]"
      }
    ]
  },
  {
    "id": 19,
    "title": "Hands-On Core Concepts #4 - Selectors",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Hands-On Core Concepts #4 - Selectors"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Reducers are responsible for maintaining the immutability of the state by returning a new state object instead of modifying the existing state directly. This approach helps in tracking changes effectively and maintaining a clear history of state changes."
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Selectors allow us to retrieve properties from the state"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "Selectors are pure functions used for obtaining slices of store state. @ngrx/store provides a few helper functions for optimizing this selection. Selectors provide many features when selecting slices of state:"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Portability"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Memoization"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Composition"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Testability"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Type Safety"
          }
        ]
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "When using the createSelector and createFeatureSelector functions @ngrx/store keeps track of the latest arguments in which your selector function was invoked. Because selectors are pure functions, the last result can be returned when the arguments match without reinvoking your selector function. This can provide performance benefits, particularly with selectors that perform expensive computation. This practice is known as memoization."
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Combining Selectors"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "By combining multiple selector functions in createSelector you can achieve comprehensive selectors that combine different states or parts of state like if you have a currentUser and wanted to filter a collection based on the CurrentUser."
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "We don't need that in this app but here is an example:"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "import { createSelector } from '@ngrx/store';\n\nexport interface User {\n  id: number;\n  name: string;\n}\n\nexport interface Book {\n  id: number;\n  userId: number;\n  name: string;\n}\n\nexport interface AppState {\n  selectedUser: User;\n  allBooks: Book[];\n}\n\nexport const selectUser = (state: AppState) => state.selectedUser;\nexport const selectAllBooks = (state: AppState) => state.allBooks;\n\nexport const selectVisibleBooks = createSelector(\n  selectUser,\n  selectAllBooks,\n  (selectedUser: User, allBooks: Book[]) => {\n    if (selectedUser && allBooks) {\n      return allBooks.filter((book: Book) => book.userId === selectedUser.id);\n    } else {\n      return allBooks;\n    }\n  }\n);"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "DeckSelectors"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Lets create a deck.selectors.ts in src/app/state"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "import { DeckState } from 'src/types/presentation-deck';\n\nimport { createFeatureSelector, createSelector } from '@ngrx/store';\n\nconst deckFeature = createFeatureSelector<DeckState>('presentation');\n\nexport const deckSelectors = {\n  deck: createSelector(deckFeature, (state: DeckState) => state),\n};\n"
      }
    ]
  },
  {
    "id": 20,
    "title": "Hands-On Core Concepts #4 - Selectors (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Super Charge Component Views w/ Selectors and Async Pipes"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Advantages to using the async pipe in the component view with NgRx"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Automatically subscribes and unsubscribes to observables like the store"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Avoid explicit subscription handling in components"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "More declarative code in templates"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Cleans up subscriptions and minimizes memory leaks"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Less boilerplate code for subscribing/unsubscribing"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Streamlines change detection by marking observables as dirty checks"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Caches results and recalculates only when the observable emits"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Handles null/undefined values before emission"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Provides hint that the data is asynchronous"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Combining the async pipe with passing state to component methods as needed,keeps those methods pure and avoids subscribing to selectors in the component class"
          }
        ]
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Now lets super charge or Deck component's view with our new selector and an Async Pipe pattern"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "First we need to add our deck selector to our deck component class"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// above the constructor add...\n\n$deckState = this.store.select(deckSelectors.deck);"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "Next we add our selector's return value of Observable<DeckState> to our view."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "<ng-container *ngIf=\"currentSlide && $deckState | async as $vm\">"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "We'll need to add currentSlide? in a couple spots to keep the view working for now until we refactor for async pipe. Additionally we now have state running side by side with our current component's class state until we refactor to only use state."
      }
    ]
  },
  {
    "id": 21,
    "title": "Hands-On Core Concepts #5 - Effects",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Hands-On Core Concepts #5 - Effects"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Effects are an RxJS powered side effect model for Store. Effects use streams to provide new sources of actions to reduce state based on external interactions such as network requests, web socket messages and time-based events."
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "In a service-based Angular application, components are responsible for interacting with external resources directly through services. Instead, effects provide a way to interact with those services and isolate them from the components. Effects are where you handle tasks such as fetching data, long-running tasks that produce multiple events, and other external interactions where your components don't need explicit knowledge of these interactions."
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Key Concepts"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Effects isolate side effects from components, allowing for more pure components that select state and dispatch actions"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Effects are long-running services that listen to an observable of every action dispatched from the Store."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Effects filter those actions based on the type of action they are interested in. This is done by using an operator."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Effects perform tasks, which are synchronous or asynchronous and return a new action."
          }
        ]
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "First install NgRx Effects"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "ng add @ngrx/effects@latest"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "Next we add deck.effects.ts"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "import { catchError, map, mergeMap, of } from 'rxjs';\nimport { deckActions } from 'src/app/state/deck.actions';\n\nimport { Injectable } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { Store } from '@ngrx/store';\n\nimport { ApiService } from '../services/api.service';\n\n@Injectable()\nexport class DeckEffects {\n  constructor(\n    private api: ApiService,\n    private actions$: Actions,\n    private store: Store\n  ) {}\n\n  loadSlides$ = createEffect(() => {\n    return this.actions$.pipe(\n      ofType(deckActions.slides.load),\n      mergeMap(() => {\n        return this.api.getSlides().pipe(\n          map((data) => deckActions.slides.loadSuccess({ payload: data })),\n          catchError((error) =>\n            of(deckActions.slides.loadFailure({ payload: error }))\n          )\n        );\n      })\n    );\n  });\n}\n"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "before registering our new DeckEffects class with our Store let look back at our Redux Tool and notice we have one action firing after init (deckActions.slides.load) and remember we are listening for that in our loadSlides$ effect in our DeckEffects class"
      },
      {
        "type": "image",
        "src": "/assets/redux1.png",
        "alt": "redux1",
        "class": "full-width"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "and now we register our DeckEffects class with the EffectsModule like so:"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "EffectsModule.forRoot([DeckEffects]),"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "now you see the result of our loadSlides$ effect calling the api and dispatching the loadSuccess action which triggers the loadSuccess Reducer and returns a new state with populated slides and a currentSlide!"
      },
      {
        "type": "image",
        "src": "/assets/redux2.png",
        "alt": "redux2",
        "class": "full-width"
      }
    ]
  },
  {
    "id": 22,
    "title": "Hands-On Core Concepts #5 - Effects (cont)",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Refactor for State & Async Pipe only"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "Here we will finally refactor our Deck component to only use our DeckSate and Async Pipe"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "First lets move our click listener to the view so we can stay pure by passing in state as needed, avoid unnecessary extra subscriptions, and all the other benefits mentioned earlier (selectors section)"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "Additionally we will remove the keydown listener and handler and do it all with the click handler"
      },
      {
        "type": "code",
        "language": "bash",
        "code": "<div class=\"slide\" [ngClass]=\"{ quiz: showQuiz }\" (click)=\"handleClick($event, $vm)\">"
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "For the sake of time, going forward I've included whole files or you can checkout the final branch #5"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "Next we will remove all the host listeners, make our click handler and all other methods, pure by passing in the current state. So our new Deck class will look like this:"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "import { deckActions } from 'src/app/state/deck.actions';\nimport { deckSelectors } from 'src/app/state/deck.selectors';\nimport { DeckState, QuestionContent } from 'src/types/presentation-deck';\n\nimport { Component, OnInit } from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { Store } from '@ngrx/store';\n\n@Component({\n  selector: 'nbme-deck',\n  templateUrl: './deck.component.html',\n  styleUrls: ['./deck.component.scss'],\n})\nexport class DeckComponent implements OnInit {\n  showQuiz = false;\n  revealAnswer = false;\n  $deckState = this.store.select(deckSelectors.deck);\n  constructor(\n    private route: ActivatedRoute,\n    private router: Router,\n    private store: Store\n  ) {}\n\n  ngOnInit() {\n    this.store.dispatch(deckActions.slides.load());\n  }\n\n  handleClick(event: MouseEvent, deckState: DeckState) {\n    if (event.clientX < window.innerWidth * 0.1) {\n      this.store.dispatch(deckActions.slides.decrement());\n      this.decrementSlide(deckState);\n    }\n\n    if (event.clientX > window.innerWidth * 0.9) {\n      this.store.dispatch(deckActions.slides.increment());\n      this.incrementSlide(deckState);\n    }\n  }\n\n  incrementSlide(deckState: DeckState) {\n    this.onHideQuiz();\n    this.revealAnswer = false;\n    if (deckState.currentSlide)\n      this.router.navigateByUrl(`/slide/${deckState.currentSlide?.id}`);\n  }\n  decrementSlide(deckState: DeckState) {\n    this.onHideQuiz();\n    this.revealAnswer = false;\n    if (deckState.currentSlide)\n      this.router.navigateByUrl(`/slide/${deckState.currentSlide?.id}`);\n  }\n\n  getSlideNumberText(deckState: DeckState) {\n    const currentIndex = deckState.slides.findIndex(\n      (slide) => slide.id === deckState.currentSlide?.id\n    );\n    return `${currentIndex + 1} / ${deckState.slides.length}`;\n  }\n\n  onShowQuiz() {\n    this.showQuiz = true;\n  }\n  onHideQuiz() {\n    this.showQuiz = false;\n  }\n  onRevealAnswer() {\n    this.revealAnswer = true;\n  }\n  getQuizData(deckState: DeckState): QuestionContent | null {\n    const found = deckState.currentSlide?.contents.filter(\n      (item) => item.type === 'question'\n    );\n    return found && found.length > 0 ? (found[0] as QuestionContent) : null;\n  }\n\n  isQuizAnswer(options: string[], option: string, answerIndex: number) {\n    return answerIndex === options.findIndex((o) => option === o);\n  }\n}\n"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "and our new view will look like this:"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "<ng-container *ngIf=\"$deckState | async as $vm\">\n  <div\n    class=\"slide\"\n    [ngClass]=\"{ quiz: showQuiz }\"\n    (click)=\"handleClick($event, $vm)\"\n  >\n    <div class=\"quiz-content\" *ngIf=\"getQuizData($vm) as quiz\">\n      <div class=\"quiz\">\n        <div class=\"question\">{{ quiz.question }}</div>\n        <ol class=\"options\" (click)=\"onRevealAnswer()\">\n          <li\n            class=\"option\"\n            [ngClass]=\"{\n              answer:\n                isQuizAnswer(quiz.options, option, quiz.answer) && revealAnswer\n            }\"\n            *ngFor=\"let option of quiz.options\"\n          >\n            {{ option }}\n          </li>\n        </ol>\n      </div>\n    </div>\n    <div class=\"content\">\n      <h1 class=\"title\">{{ $vm.currentSlide?.title }}</h1>\n      <ng-container\n        *ngFor=\"let contentItem of $vm.currentSlide?.contents; index as i\"\n      >\n        <ng-container *ngIf=\"contentItem.type === 'text'\">\n          <p [class]=\"contentItem.role\">{{ contentItem.content }}</p>\n        </ng-container>\n        <ng-container *ngIf=\"contentItem.type === 'list'\">\n          <ul>\n            <li *ngFor=\"let listItem of contentItem.items\">\n              {{ listItem.content }}\n            </li>\n          </ul>\n        </ng-container>\n        <ng-container *ngIf=\"contentItem.type === 'code'\">\n          <pre><code class=\"language-typescript\" [class]=\"'code'\">{{ contentItem.code }}</code></pre>\n        </ng-container>\n        <ng-container *ngIf=\"contentItem.type === 'question'\">\n          <button class=\"quiz-btn\" (click)=\"onShowQuiz()\">Quiz!</button>\n        </ng-container>\n        <ng-container *ngIf=\"contentItem.type === 'image'\">\n          <div class=\"img-wrap\">\n            <img\n              [src]=\"contentItem.src\"\n              [alt]=\"contentItem.alt\"\n              [class]=\"contentItem.class\"\n            />\n          </div>\n        </ng-container>\n      </ng-container>\n    </div>\n    <div class=\"counter\">{{ getSlideNumberText($vm) }}</div>\n  </div>\n</ng-container>\n"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "and finally our new reducers will look like this:"
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "import { DeckState } from 'src/types/presentation-deck';\n\nimport { createReducer, on } from '@ngrx/store';\n\nimport { deckActions } from './deck.actions';\n\nexport const initialDeckState: Readonly<DeckState> = {\n  currentSlide: null,\n  slides: [],\n};\n\nexport const DeckReducer = createReducer(\n  initialDeckState,\n  on(deckActions.slides.loadSuccess, (state, { payload }) => {\n    const newState: DeckState = {\n      ...state,\n      slides: payload,\n      currentSlide: payload[0],\n    };\n    return newState;\n  }),\n  on(deckActions.slides.increment, (state) => {\n    const newState: DeckState = { ...state }; // necessary as it is Readonly\n    // increment logic here\n    const currentIndex = state.slides.findIndex(\n      (slide) => slide.id === state.currentSlide?.id\n    );\n    const nextIndex = currentIndex + 1;\n    if (nextIndex < state.slides.length) {\n      newState.currentSlide = state.slides[nextIndex];\n    }\n    return newState;\n  }),\n  on(deckActions.slides.decrement, (state) => {\n    const newState: DeckState = { ...state };\n    // decrement logic here\n    const currentIndex = state.slides.findIndex(\n      (slide) => slide.id === state.currentSlide?.id\n    );\n    const nextIndex = currentIndex - 1;\n    if (nextIndex >= 0) {\n      newState.currentSlide = state.slides[nextIndex];\n    }\n    return newState;\n  })\n);\n"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "It is worth noting here that, from an optimization perspective, we can switch our component update strategy to OnPush now that all the data is coming through the view with an AsyncPipe. Using OnPush change detection will prevent unnecessary change detection cycles and improve performance."
      }
    ]
  },
  {
    "id": 23,
    "title": "Advanced Concepts",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "Advanced Concepts"
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Router Store"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Router store contains the state of the Angular router in the NgRx store."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "It dispatches ROUTER_NAVIGATION actions to store history events, url, navigationId etc."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Selectors provide the router state and url. Can select query/url parameters."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Allows router to participate in state management. Can persist state across navigation."
          }
        ]
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Meta Reducers"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Meta reducers are functions that take a reducer function and return a new reducer."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "They allow writing code that runs before/after each dispatched action is processed."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Use cases: logging, debugging, persisting state to localStorage etc."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "NgRx provides meta reducers for development tools, router store, storing rehydrated state."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Can compose multiple meta reducers by wrapping the previous meta reducer."
          }
        ]
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Entity"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Entity is used to manage domain models in a normalized state. It provides adapter classes for managing collections of models."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "The entity state is normalized, storing models in a map by ID instead of arrays. This avoids duplication and makes lookups faster."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Entity adapters handle common CRUD operations like add/update/delete without needing explicit actions."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Selectors are provided for getting slices of entity state, filtering, sorting etc."
          }
        ]
      }
    ]
  },
  {
    "id": 24,
    "title": "NgRx best practices",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "NgRx best practices"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Structure state and reducers based on feature areas - Keeps state manageable and easier to find code."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Make state immutable by returning new copies - Avoids mutations that cause bugs."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Use selectors for reading state - Avoid spreading state to components."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Use effects for side effects - Keeps them isolated from components."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Use consistent and descriptive action types - Makes actions and effects more readable and traceable."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Dispatch one action for each effect - Keep effects simple and focused on one task."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Use router store to sync router state - Integrates router with state management."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Make effects idempotent - Avoids duplicate side effects if retried."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Use Entity for managing domain models - It provides normalized state and reusable CRUD operations."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Decouple state updates from component classes - Use actions/reducers instead of setters."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Load minimal data needed - Avoid large unfiltered selects, use entity memoization."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Use creator functions for complex actions - Keeps action types consistent and reusable."
          }
        ]
      }
    ]
  },
  {
    "id": 25,
    "title": "Conclusion",
    "contents": [
      {
        "type": "text",
        "role": "heading",
        "content": "In Conclusion..."
      },
      {
        "type": "text",
        "role": "subheading",
        "content": "When starting out with NgRx, it's best not to over complicate things. Jumping right into building a complex state management system for a large, real-world application can quickly become overwhelming."
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "Instead, take an incremental approach:"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Start by setting up the basic store, actions, reducers."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Manage a small piece of state at first, like a user profile."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Add selectors, actions, and effects incrementally."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Avoid advanced concepts like router integration early on."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Build small demos and projects to experiment."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Focus on core principles like immutability first."
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Don't over-architect too early. Start simple."
          }
        ]
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "The goal is to start small, get comfortable with the basics, and incrementally expand your knowledge. Once you have a handle on the core concepts, you can then start building more complex, real-world applications with NgRx."
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "The key is resist the urge to over-architect things too early. Stay focused on small pieces that illustrate the basics well. Learning NgRx takes time, but starting simple makes it much more approachable."
      },
      {
        "type": "text",
        "role": "heading",
        "content": "Feature Assignments:"
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "I've left a few features/bugs out of the app for you to implement. Try to tackle them on your own by creating a feature branch from 'hands-on-5-add-ngrx-effects' and then submitting a PR to the repo."
      },
      {
        "type": "text",
        "role": "paragraph",
        "content": "https://github.com/jzevin/ngrx-training-8-2023/tree/hands-on-5-add-ngrx-effects"
      },
      {
        "type": "list",
        "listType": "ordered",
        "items": [
          {
            "type": "text",
            "role": "list-item",
            "content": "Loading indicator"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Slides nav"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Fix router bug after our re-factor"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Move quiz data to state and refactor deck comp"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Add undo/redo functionality"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Secured routes"
          },
          {
            "type": "text",
            "role": "list-item",
            "content": "Settings page with additional state slice"
          }
        ]
      }
    ]
  }
]
